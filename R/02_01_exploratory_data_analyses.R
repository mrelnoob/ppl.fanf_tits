# ---------------------------------------------------------------------------------- #
#####              Function for all exploratory data analyses (EDA)              #####
# ---------------------------------------------------------------------------------- #

### Script preparations ________________________________________________________
# I first need to source some of my previous R scripts to be able to call their functions:
source(file = here::here("R/01_02_utility_functions.R"))
source(file = here::here("R/01_03_preparing_data.R"))

library(magrittr) # The only library that I truly need to load (in order to be able to use pipes).

utils::globalVariables("where") # This is necessary for now as tidyselect::where is not an
# exported function!





### _______________________________________________________
#' Exploratory DATA Analyses and final tits data formatting
#'
#' @description (THEORETICALLY MEANT FOR INTERNAL USE ONLY, use with caution!).
#' The `tfinal_EDAta` function loads and modifies the dataset generated by the last praparing
#' function: (\code{\link[tdata_upD_final]{tdata_upD_final}}). It completes these data with
#' a few additional inputs and corrections, and then use them to explore the data's main
#' statistical properties.
#' Finally, the function exports the updated dataset as a tibble or as a new .csv file.
#'
#' @return A list containing five elements: 1) the updated "clean" dataset (a tibble
#' accessible with `tdata_upD_final()$clean_dataset`); 2) the dataset before imputations but
#' containing all data corrections applied by the function (a tibble accessible with
#' `tdata_upD_final()$priorimp_dataset`); 3 and 4) tables showing the out-of-bag imputation
#' error for both species and for each of the four "buffer radius" (accessible with
#' `tdata_upD_final()$impute_error` followed by the desired species code (e.g. "_pm";
#' cf. examples)); and 5) the path to the exported .csv file of the updated "clean" dataset
#' (`ndata_clean.csv`; accessible with `tdata_upD_final()$path`).
#'
#' @export
#' @importFrom here here
#' @importFrom readr read_csv2
#' @importFrom readr cols
#' @importFrom readr col_factor
#' @importFrom readr col_integer
#' @importFrom readr col_date
#' @importFrom readr write_csv2
#' @importFrom dplyr mutate
#' @importFrom dplyr filter
#' @importFrom dplyr select
#' @importFrom dplyr relocate
#' @importFrom dplyr rename
#' @importFrom dplyr across
#' @importFrom assertthat is.date
#' @importFrom missForest missForest
#'
#' @examples
#' \dontrun{
#' # To obtain the data and imputation error regarding the 50m buffer data:
#' mydata <- tdata_upD_final()$clean_dataset
#' mydata %>% dplyr::filter(dist == 50) -> mydata_50
#' mydata <- tdata_upD_final()$priorimp_dataset # May be useful to compare the results of
#' # missing data imputations.
#' myerror_pm <- tdata_upD_final()$impute_error_pm
#' myerror_cc <- tdata_upD_final()$impute_error_cc
#' path_to_csv <- tdata_upD_final()$path
#' }
tfinal_EDAta <- function(){
  ###################### ********************************************* ###########################
  # -------------------------------------- #
  ##### 1. Data import and preparation #####
  # -------------------------------------- #

  ##### * 1.1. Data import and formatting ----------------------------------------
  # ---------------------------------------------------------------------------- #

  .pardefault <- par()

  ### ** 1.1.1. Import ----
  # _______________________

  tits_clean <- tdata_upD_final()$clean_dataset
  tits_clean %>% dplyr::filter(dist == 150) -> tits_clean # Only selects the 150m-based dataset!

  manag <- readr::read_csv2(here::here("data", "veg_manag_factor.csv"), # To import another (late
                            # coming) independent variable.
                            col_names = TRUE, na = "NA",
                            col_types = readr::cols(id_nestbox = readr::col_factor(),
                                                    manag_intensity = readr::col_factor(
                                                      levels = c("0", "1", "2"),
                                                      include_na = FALSE)))
  tits_clean <- dplyr::inner_join(tits_clean, manag, by = "id_nestbox")

  ### To import the connectivity metrics computed for both species (using the Bash script provided
  # in the '02_00_graphab_analyses.R' file):
  cmetrics_pm <- readr::read_csv2(here::here("data", "cmetrics_pm.csv"),
                                  col_names = TRUE, na = "NA",
                                  col_types = readr::cols(id_nestbox = readr::col_factor(),
                                                          id_patch = readr::col_factor()))
  cmetrics_pm %>% dplyr::select(-cost_to_patch, -id_patch, -patch_area, -perim,
                                -pmRr_d1_capa2, -pmRr_d2_capa2, -pmRr_d3_capa2) %>%
    dplyr::inner_join(tits_clean, cmetrics_pm, by = "id_nestbox", multiple = "all") -> ttt # Only
  # selects some metrics!

  cmetrics_cc <- readr::read_csv2(here::here("data", "cmetrics_cc.csv"),
                                  col_names = TRUE, na = "NA",
                                  col_types = readr::cols(id_nestbox = readr::col_factor(),
                                                          id_patch = readr::col_factor()))
  cmetrics_cc %>% dplyr::select(-cost_to_patch, -ccRr_d1_capa2, -ccRr_d2_capa2, -ccRr_d3_capa2) %>%
    dplyr::inner_join(ttt, cmetrics_cc, by = "id_nestbox", multiple = "all") -> ttt # Only selects
  # some metrics!


  ### ** 1.1.2. Binding ----
  # ________________________

  tits_clean$age_num <- as.numeric(as.character(tits_clean$age_class))
  tits_clean$strata_num <- as.numeric(as.character(tits_clean$strata_div))
  tits_clean$manag_num <- as.numeric(as.character(tits_clean$manag_intensity))
  tits_clean %>%  dplyr::relocate(manag_intensity, .after = age_class) -> tits_clean
  tits_clean %>%  dplyr::relocate(manag_num, .after = manag_intensity) -> tits_clean
  tits_clean %>%  dplyr::relocate(age_num, .after = age_class) %>%
    dplyr::rename(traffic = trafic) -> tits_clean

  ntits <- cbind(tits_clean, ttt[,2:26]) # To select all patch related variables!
  ntits %>% dplyr::select(-dist, -breeding_window, -father_id, -mother_id, -mean_winter_t,
                          -sd_winter_t, -lsource_vs150_m, -lsource_vs150_iq,
                          -soft_manag_area) -> ntits
  rm(ttt, cmetrics_pm, cmetrics_cc, manag, tits_clean)
  ntits <- tibble::as_tibble(ntits)

  # Weighting of woodyveg_volume with strata_num:
  ntits %>% dplyr::mutate(strata_w = dplyr::case_when(
    strata_div == "0" ~ 0.25,
    strata_div == "1" ~ 0.5,
    strata_div == "2" ~ 0.6,
    strata_div == "3" ~ 0.75,
    strata_div == "4" ~ 0.9)) %>%
    dplyr::mutate(woodyveg_vw = woodyveg_volume*strata_w) %>%
    dplyr::select(-strata_div, -strata_num, -strata_w) %>%
    dplyr::relocate(woodyveg_vw, .after = woodyveg_sd) %>%
    dplyr::rename(patch_perim = perim) -> ntits



  ##### * 1.2. Data reduction ----------------------------------------------------
  # ---------------------------------------------------------------------------- #

  ### For variables related to vegetation characteristics_________________________#
  # Does not yield meaningful results.

  ### For variables related to landscape composition______________________________#
  ntits %>% dplyr::select(id_nestbox, site, built_area, build_volume,
                          build_sd, open_area) -> xxx # In the end, I decided to remove traffic!

  # Normed-PCA:
  res.pca <- FactoMineR::PCA(X = xxx[, 3:ncol(xxx)], scale.unit = TRUE, graph = FALSE)
  # To plot results:
  landscape.varplot <- factoextra::fviz_pca_var(res.pca, col.var = "contrib",
                                                gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
                                                repel = TRUE)
  landscape.indplot <- plot(res.pca, choix = "ind", autoLab = "yes")
  #gridExtra::grid.arrange(landscape.varplot, landscape.indplot, ncol = 2)

  # As the first axis (PC) of my PCA satisfactorily synthesizes a large amount of the
  # variance (70.2%)*** of my four variables, we can use the coordinates of observations on
  # this axis as a synthetic variable:
  zzz <- res.pca$ind$coord[,1]
  ntits$urban_intensity <- zzz # This variable opposes nestboxes located in very dense urban
  # areas with less densely urbanised (or even not-urbanised) areas.



  ### For variables related to light pollution____________________________________#
  ntits %>% dplyr::select(id_nestbox, site,
                          lsource_0_m, lsource_10_m, lflux_0_m, lflux_10_m) -> xxx

  # Normed-PCA:
  res.pca <- FactoMineR::PCA(X = xxx[, 3:ncol(xxx)], scale.unit = TRUE, graph = FALSE)
  # To plot results:
  lightpol.varplot <- factoextra::fviz_pca_var(res.pca, col.var = "contrib",
                                               gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
                                               repel = TRUE)
  lightpol.indplot <- plot(res.pca, choix = "ind", autoLab = "yes")
  #gridExtra::grid.arrange(lightpol.varplot, lightpol.indplot, ncol = 2)

  # As the first axis (PC) of my PCA satisfactorily synthesizes a large amount of the variance
  # (75.7%)*** of my four variables, we can use the coordinates of observations on this axis as
  # a synthetic variable:
  zzz <- res.pca$ind$coord[,1]
  ntits$light_pollution <- zzz # This variable opposes nestboxes located in areas experiencing
  # strong light pollution against more preserved areas.



  ##### * 1.3. Datasets formatting -----------------------------------------------
  # ---------------------------------------------------------------------------- #

  ntits[which(ntits$noise_m == min(ntits$noise_m)), "noise_m"] <- 31
  ntits %>% dplyr::mutate(
    F_metric_d1b0 = dplyr::case_when(
      species == "PM" ~ pmF_d1_beta0, species == "CC" ~ ccF_d1_beta0),
    F_metric_d2b0 = dplyr::case_when(
      species == "PM" ~ pmF_d2_beta0, species == "CC" ~ ccF_d2_beta0),
    F_metric_d3b0 = dplyr::case_when(
      species == "PM" ~ pmF_d3_beta0, species == "CC" ~ ccF_d3_beta0),
    F_metric_d1b1 = dplyr::case_when(
      species == "PM" ~ pmF_d1_beta1, species == "CC" ~ ccF_d1_beta1),
    F_metric_d2b1 = dplyr::case_when(
      species == "PM" ~ pmF_d2_beta1, species == "CC" ~ ccF_d2_beta1),
    F_metric_d3b1 = dplyr::case_when(
      species == "PM" ~ pmF_d3_beta1, species == "CC" ~ ccF_d3_beta1),
    Rr_metric_d1c1 = dplyr::case_when(
      species == "PM" ~ pmRr_d1_capa1, species == "CC" ~ ccRr_d1_capa1),
    Rr_metric_d2c1 = dplyr::case_when(
      species == "PM" ~ pmRr_d2_capa1, species == "CC" ~ ccRr_d2_capa1),
    Rr_metric_d3c1 = dplyr::case_when(
      species == "PM" ~ pmRr_d3_capa1, species == "CC" ~ ccRr_d3_capa1),
    Dr_metric_c1 = dplyr::case_when(
      species == "PM" ~ pmDr_capa1, species == "CC" ~ ccDr_capa1),
    Dr_metric_c2 = dplyr::case_when(
      species == "PM" ~ pmDr_capa2, species == "CC" ~ ccDr_capa2),
  ) %>%
    dplyr::select(id_nestbox, id_patch, site, coord_x, coord_y, year, species, laying_date,
                  flight_date, clutch_size, brood_size, fledgling_nb, mass, tarsus_length,
                  wing_length, F_metric_d1b0, F_metric_d2b0, F_metric_d3b0, F_metric_d1b1,
                  F_metric_d2b1, F_metric_d3b1, Rr_metric_d1c1, Rr_metric_d2c1, Rr_metric_d3c1,
                  Dr_metric_c1, Dr_metric_c2, woodyveg_volume, woodyveg_vw, woodyveg_sd,
                  woody_area, patch_area, patch_perim, herbaceous_area, manag_intensity,
                  light_pollution, noise_m, noise_iq,
                  traffic, built_area, build_volume, build_sd, open_area, water_area, urban_intensity,
                  cumdd_30, cumdd_60, cumdd_between, min_t_before, min_t_between) -> ntits_reduced
  rm(res.pca, xxx, zzz)





  ###################### ********************************************* ###########################
  # --------------------------- #
  ##### 2. Data exploration #####
  # --------------------------- #

  ##### * 2.1. Univariate outliers -----------------------------------------------
  # ---------------------------------------------------------------------------- #

  uni.boxplots(ntits_reduced[,16:ncol(ntits_reduced)]) # Only for IVs, not Ys.
  uni.dotplots(ntits_reduced[,16:ncol(ntits_reduced)])
  # We can see that:
  # - There are extreme values for many variables.
  # - Many variables are quite strongly left-skewed.
  # - As expected, "water_area" has a very strange distribution.
  # - Otherwise, the IVs look relatively nice.



  ##### * 2.2. Normality, skewness and kurtosis ----------------------------------
  # ---------------------------------------------------------------------------- #

  uni.histograms(ntits_reduced[,16:ncol(ntits_reduced)])

  ntits.x <- ntits_reduced[,16:ncol(ntits_reduced)]
  ntits.xnum <- ntits.x[, sapply(ntits.x, is.numeric)] # To only select numeric variables.
  tab <- data.frame(moments::skewness(x = ntits.xnum), moments::kurtosis(x = ntits.xnum)-3)
  ntitsx_skewkurtable <- knitr::kable(x = tab, digits = 3,
                                      col.names = c("Skewness", "Excess kurtosis"))
  # If skewness values are fairly acceptable for most variables (although F_metric_d3b1
  # and water_area > 3), several variables present (sometimes very) excessive kurtosis:
  # - K > 3: F_metric_d1b0, F_metric_d2b1, Dr_metric_c1, patch_area, build_volume.
  # - K > 4: F_metric_d1b1, woodyveg_volume, noise_m.
  # - K > 5: woodyveg_vw, woodyveg_volume, water_area.
  # - K > 10: F_metric_d3b1 !
  rm(tab)








  ##### * 2.3. Multivariate relationships ----------------------------------------
  # ---------------------------------------------------------------------------- #

  ntits.xnum %>%
    dplyr::select(-F_metric_d3b0, -F_metric_d3b1, -Rr_metric_d1c1, -woodyveg_volume) -> ntits.xnum
  # To compute the correlation matrix:
  res.cor.ntitsx <- round(stats::cor(ntits.xnum, use = "complete.obs", method = "spearman"), 2)
  # To compute a matrix of correlation p-values:
  res.pcor.ntitsx <- ggcorrplot::cor_pmat(x = ntits.xnum, method = "spearman")

  ntitsx.corplot <- ggcorrplot::ggcorrplot(res.cor.ntitsx, type = "upper",
                                           outline.col = "white",
                                           ggtheme = ggplot2::theme_gray,
                                           colors = c("#6D9EC1", "white", "#E46726"),
                                           p.mat = res.pcor.ntitsx,
                                           insig = "blank")
  # We can see that:
  # - All connectivity metrics and woodyveg variables are quite strongly positively correlated,
  #   but negatively with the urban intensity and pollution variables. That's quite unsurprising,
  #   the more woody vegetation in the landscape, the more connectivity, and the less room for
  #   urban features such as buildings, roads, pollution emissions, etc.
  # - Herbaceous areas are less strongly correlated that woody areas.
  # - Patch area and perimeters are very strongly correlated!
  # - Quite logically, the pollution variables are positively correlated with other urban related
  #   ones.
  # - We see that temperature variables are not much correlated with any variable.
  # - Interestingly, "min_t_before" is slightly correlated with most variables when "min_t_between"
  #   is not! It also shows that the minimal temperature before laying tends to be higher when there
  #   is not much vegetation (i.e. when the stations are located in densely urbanised areas).

  ntitsx.pairplot <- GGally::ggpairs(ntits.xnum)
  # We find again the same patterns. Yet, we can see that:
  # - Some relationships are actually not linear but curvilinear.
  # - There may be problematic outliers, particularly for noise_m.

  ### CONCLUSION: we decided to focus mainly on the "F_metric_d2b1" and "patch_area" as focal
  # proxies of our variables of interest (connectivity and the size of the nesting/foraging
  # habitats) for three reasons: (i) they were the ones that made most sense (also, it's easier
  # to stick with the "F-metric" with a regular weighting (i.e. beta 1) than to explain in a paper
  # that we specifically invented new connectivity metrics (i.e. Rr and Dr) or that we explored
  # fancy parametrisations); (ii) they do not present crippling properties; and (iii) they are
  # among the proxies showing the least correlation with other variables (which could help
  # preventing multicollinearity).





  ###################### ********************************************* ###########################
  # ---------------------------------------------------------- #
  ##### 3. Exploration of the potential response variables #####
  # ---------------------------------------------------------- #

  # In this section, we simply explore some properties of our "potential" response variables
  # to see whether something is wrong with them. Of course, we explored them without looking
  # at their relationships with the predictors, otherwise that would have been "cherry-picking".



  ##### * 3.1. Outliers and distributions ----------------------------------------
  # ---------------------------------------------------------------------------- #

  ntits.y <- ntits_reduced[,10:15]

  ### For NTITS___________________________________________________________________#

  uni.boxplots(ntits.y)
  uni.dotplots(ntits.y)
  # we can say that the 6 DV (dependant variables) have relatively nice distributions although
  # we seem to have a zero-inflation for "brood_size" and "fledgling_nb", as well as a slight
  # left-skewness for the morphometric variables (possibly linked to the differences among tit
  #  species).
  tab <- data.frame(moments::skewness(x = stats::na.omit(ntits.y)),
                    moments::kurtosis(x = stats::na.omit(ntits.y))-3)
  ntitsy_skewkurtable <- knitr::kable(x = tab, digits = 3, col.names = c("Skewness",
                                                                         "Excess kurtosis"))
  # But skewness and kurtosis values are very satisfactory.



  ##### * 3.2. Multivariate relationships ----------------------------------------
  # ---------------------------------------------------------------------------- #

  # To compute the correlation matrix:
  res.cor.ntitsy <- round(stats::cor(ntits.y, use = "complete.obs", method = "spearman"), 2)
  # To compute a matrix of correlation p-values:
  res.pcor.ntitsy <- ggcorrplot::cor_pmat(x = ntits.y, method = "spearman")

  ntitsy.corplot <- ggcorrplot::ggcorrplot(res.cor.ntitsy, type = "upper",
                                           outline.col = "white",
                                           ggtheme = ggplot2::theme_gray,
                                           colors = c("#6D9EC1", "white", "#E46726"),
                                           p.mat = res.pcor.ntitsy,
                                           insig = "blank")
  # We can see that:
  # - The 3 reproductive variables are strongly positively correlated and so are the three
  #   morphometric ones!
  # - Both "clutch_size" and "brood_size" seem to be negatively correlated with the morphometric
  #   variables suggesting that when large clutches or broods lead to smaller chicks!
  # - Interestingly, the number of fledglings seem uncorrelated with nestlings morphology.

  ntitsy.pairplot <- GGally::ggpairs(ntits.y)
  # We can see that:
  # - The positive relationship among the morphometric variables is undeniable.
  # - The zero-inflation may be due to another process as the total failures in "brood_size"
  #   or "fledgling_nb" (i.e. 0's) appear unrelated with the numbers of the preceding processes
  #   (e.g. egg laying or hatching).
  # - The negative correlation between "clutch_size" and "brood_size" and the morphometric
  #   variables is not so clear here but seem to exist nonetheless. However, it may be an artefact
  #   of "species" because CC is smaller but tends to be more productive (see below).

  # Disclaimer, remind that:
  # - PM: CS ranges 2-12 (mode 8); BS 0-12 (8); FN 0-11 (0 or 6);
  #       MA 9.9-18.4 (mean 14.8); TL 15.7-20.6 (18.9); WL 27-50.4 (41.5).
  # - CC: CS ranges 2-14 (mode 11); BS 0-14 (10); FN 0-12 (0 or 8);
  #       MA 5.8-13 (mean 9); TL 12-17.7 (15.8); WL 17.5-40.1 (32.9).





  ###################### ********************************************* ###########################
  # -------------------------------- #
  ##### 4. Final data formatting #####
  # -------------------------------- #

  rm(tab, ntits.x, ntits.y, ntits.xnum, res.cor.ntitsx, res.pcor.ntitsx)

  ntits_reduced %>% dplyr::mutate(Dr_metric_c1 = Dr_metric_c1/1000, # Changing scale of the
                                  # cost-distance.
                                  Dr_metric_c2 = Dr_metric_c2/1000, # Changing scale of the
                                  # cost-distance.
                                  noise_m = noise_m/10, # Converting dB into B.
                                  cumdd_30 = cumdd_30/100, # Converting degree-days into hundred
                                  # of degree-days.
                                  cumdd_between = cumdd_between/100,
                                  traffic = traffic/1000000, # Conversion to millions of
                                  # metre.vehicles per day!
                                  built_area = built_area/1000, # Converting m2 into km2.
                                  built_volume = build_volume/1000, # Converting m3 into dm3.
                                  open_area = open_area/1000) %>%
    dplyr::mutate(brood_size = round(brood_size, digits = 0), # There was a decimal count.
                  log_F_metric_d1b0 = log10(F_metric_d1b0), # Predictors rescaling or normalisation.
                  log_F_metric_d2b0 = log10(F_metric_d2b0),
                  log_F_metric_d3b0 = log10(F_metric_d3b0),
                  log_F_metric_d1b1 = log10(F_metric_d1b1),
                  log_F_metric_d2b1 = log10(F_metric_d2b1),
                  log_F_metric_d3b1 = log10(F_metric_d3b1),
                  log_woody_vol = log10(woodyveg_volume),
                  log_woody_vw = log10(woodyveg_vw),
                  log_woody_area = log10(woody_area),
                  log_patch_area = log10(patch_area),
                  log_patch_perim = log10(patch_perim),
                  log_herb_area = log10(herbaceous_area),
                  sqrt_built_vol = sqrt(built_volume)) %>%
    dplyr::mutate(brood_size = as.integer(brood_size),
                  hatching_rate = brood_size/clutch_size,
                  laying_day = lubridate::yday(laying_date)/10) %>% # Computing and rescaling
    # laying day!
    dplyr::mutate(year = stats::relevel(x = year, ref = 3), # Assign 2019 as the reference group.
                  species = stats::relevel(x = species, ref = 2)) %>% # Assign PM as the
    # reference group.
    dplyr::mutate(manag_low = ifelse(manag_intensity == "0", "1", "0"),
                  manag_mid = ifelse(manag_intensity == "1", "1", "0"),
                  manag_high = ifelse(manag_intensity == "2", "1", "0")) %>%
    dplyr::mutate(dplyr::across(where(is.matrix), as.numeric),
                  dplyr::across(where(is.character), as.factor)) %>%
    dplyr::mutate(coord_y = jitter(x = coord_y, factor = 1.2)) %>%
    dplyr::mutate(coord_x = jitter(x = coord_x, factor = 1.2)) -> ntits2

  # To enable exploring some interaction models, I further median-centre some of the variables:
  ntits2 %>% dplyr::mutate(c.log_patch_area = log_patch_area-stats::median(log_patch_area),
                           c.log_woody_vol = log_woody_vol-stats::median(log_woody_vol),
                           c.log_woody_area = log_woody_area-stats::median(log_woody_area),
                           c.log_F_metric_d2b1 = log_F_metric_d2b1-stats::median(log_F_metric_d2b1),
                           c.log_F_metric_d2b0 = log_F_metric_d2b0-stats::median(log_F_metric_d2b0),
                           c.clutch_size = clutch_size-stats::median(clutch_size),
                           c.laying_day = laying_day-stats::median(laying_day),
                           c.sqrt_built_vol = sqrt_built_vol-stats::median(sqrt_built_vol),
                           c.built_area = built_area-stats::median(built_area),
                           c.open_area = open_area-stats::median(open_area),
                           c.log_herb_area = log_herb_area-stats::median(log_herb_area),
                           c.noise_m = noise_m-stats::median(noise_m),
                           c.traffic = traffic-stats::median(traffic),
                           c.cumdd_30 = cumdd_30-stats::median(cumdd_30),
                           c.cumdd_between = cumdd_between-stats::median(cumdd_between),
                           c.min_t_between = min_t_between-stats::median(min_t_between)) -> ntits2
  ntits2[ntits2$id_nestbox == "DIJ-205" & ntits2$year == "2019", "species"] <- "PM" # Misidentified
  # observation.

  # summary(ntits2[,35:ncol(ntits2)])
  # uni.dotplots(ntits2[,45:ncol(ntits2)]) # If needed.
  colnames(ntits2)

  # return(ntits2) OR LIST?????????????????????????
}

